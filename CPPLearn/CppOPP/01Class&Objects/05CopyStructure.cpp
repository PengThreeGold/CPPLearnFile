// 拷贝构造函数
// 拷贝构造函数创建对象时，是使用同一类之前创建的对象来初始化新创建的对象
// 用法如下：
//      1、通过使用另一个同类型的对象来初始化新创建的对象
//      2、复制对象把它作为参数传递给函数
//      3、复制对象，并从函数返回这个对象
// 注意：
//      1、如果在类中没有定义拷贝构造函数，编译器会自行定义一个。
//      2、如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数
// 基本形式：
// classname (const classname &obj){ // 构造函数的主体}
// obj是一个对象引用，该对象是用于初始化另一个对象的

// 拷贝构造函数原则
/*
1、拷贝构造函数是一种特殊的含有单个形参（常用const修饰）的构造函数
2、该形参是对该类型的引用
3、定义新对象并使用同类型对象初始化时，将显式使用拷贝构造函数
4、该类型的对象传递给函数或从函数返回该类型对象时，将隐式调用拷贝构造函数
*/

// C++支持两种初始化形式
// A x(0); // 直接初始化，调用构造函数
// A a_copy = a; // 拷贝初始化，调用拷贝构造函数
/*
Q：为什么当类成员含有指针类型成员且对其分配内存时，必须定义拷贝构造函数？
A:
    默认的拷贝构造函数实现的只能是浅拷贝，
    即直接将原对象的数据成员值依次赋值给新对象中对应的数据成员，
    并没有为新对象另外分配内存资源。
    如果此时对象的数据成员是指针，
    两个指针对象实际上指向的是同一块内存空间。
    这样容易存在安全隐患。
    所以当类的数据成员含有指针类型时，必须定义一个特定的拷贝构造函数，
    该拷贝构造函数不仅可以实现对原对象和新对象之间的数据成员的拷贝。
    而且可以为新的对象分配单独的内存资源，即为深拷贝构造函数。
*/

/*
Q: 如何防止默认拷贝发生
A:
    声明一个私有的拷贝构造函数，这样因为拷贝构造函数是私有的，
    如果用户试图按值传递或函数返回该类的对象则编译器会报错，
    从而避免按值传递或返回对象。
*/

/*
指针悬挂现象：
    当数据成员中有指针时，
    如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，
    当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。
解决方案：
    采用深拷贝，深拷贝会在堆内存中另外申请空间来存储数据。

*/

#include <iostream>

using namespace std;

class Line
{
public:
    int getLength(void);
    Line(int len);         // 简单的构造函数
    Line(const Line& obj); // 拷贝构造函数
    ~Line();               // 析构函数

private:
    int* ptr;
};

// 成员函数定义，包括构造函数
Line::Line(int len)
{
    cout << "调用构造函数" << endl;
    // 为指针分配内存
    this->ptr = new int;
    *ptr = len; // 拷贝值
}

Line::Line(const Line& obj)
{
    cout << "调用拷贝构造函数并为指针ptr分配内存" << endl;
    this->ptr = new int;
    *ptr = *obj.ptr; // 拷贝值
}

Line::~Line(void)
{
    cout << "释放内存" << endl;
    delete ptr;
}

int Line::getLength(void)
{
    return *ptr;
}

void display(Line obj)
{
    cout << "line 大小 ： " << obj.getLength() << endl;
}

// 程序主函数
int main() {
    // 方式1
    Line line(10);
    display(line);

    // 方式2
    Line line1 = line; // 这里也调用了拷贝构造函数
    display(line1);

    return 0;
}
